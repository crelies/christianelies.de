<!DOCTYPE html><html><head><meta charset="UTF-8"/><meta name="og:site_name" content="Meet crelies"/><link rel="canonical" href="https://christianelies.de/posts/remote-image-view"/><meta name="twitter:url" content="https://christianelies.de/posts/remote-image-view"/><meta name="og:url" content="https://christianelies.de/posts/remote-image-view"/><title>Learn and Master Remote Image View inÂ SwiftUI | Meet crelies</title><meta name="twitter:title" content="Learn and Master Remote Image View inÂ SwiftUI | Meet crelies"/><meta name="og:title" content="Learn and Master Remote Image View inÂ SwiftUI | Meet crelies"/><meta name="description" content="Fetching, caching, error, and loadingÂ view"/><meta name="twitter:description" content="Fetching, caching, error, and loadingÂ view"/><meta name="og:description" content="Fetching, caching, error, and loadingÂ view"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/css/bootstrap.min.css" type="text/css"/><link rel="stylesheet" href="/css/all.min.css" type="text/css"/><link rel="stylesheet" href="/css/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Meet crelies"/></head><body><header><div class="text-center pt-4"><a class="text-monospace main-link" href="/"><p class="mb-0">crelies.swift</p></a></div><nav class="navbar navbar-expand-lg justify-content-center"><div class="navbar-nav"><a class="nav-item nav-link" href="/me">.me</a><a class="nav-item nav-link active" href="/posts">.posts</a><a class="nav-item nav-link" href="/projects">.projects</a></div></nav><ul class="list-inline text-center pb-4 mb-0 social-links"><li class="list-inline-item"><a target="_blank" href="https://github.com/crelies"><i class="fab fa-github"></i></a></li><li class="list-inline-item"><a target="_blank" href="https://medium.com/@crelies"><i class="fab fa-medium"></i></a></li><li class="list-inline-item"><a target="_blank" href="https://stackoverflow.com/story/crelies"><i class="fab fa-stack-overflow"></i></a></li><li class="list-inline-item"><a target="_blank" href="https://www.xing.com/profile/Christian_Elies2"><i class="fab fa-xing"></i></a></li><li class="list-inline-item"><a target="_blank" href="https://www.linkedin.com/in/christian-elies-b1009b104"><i class="fab fa-linkedin"></i></a></li></ul></header><div class="page-wrapper item"><h1>Learn and Master Remote Image View inÂ SwiftUI</h1><a href="/tags/image"><span class="badge badge-pill badge-success fs-12 text-monospace pt-2 pb-2 mr-2 mb-2">image</span></a><a href="/tags/swiftui"><span class="badge badge-pill badge-info fs-12 text-monospace pt-2 pb-2 mr-2 mb-2">swiftui</span></a><p class="post date">12. Aug 2019</p><img src="remote-image-view-header.png" alt="Fictional RemoteImage initializer"/><p><em>Fictional RemoteImage initializer</em></p><p><strong>Update 2019/08/14:</strong> Now available as a <a href="https://github.com/crelies/RemoteImage">Swift package</a> ðŸš€</p><p>I want to implement a <a href="https://developer.apple.com/documentation/swiftui">SwiftUI</a> pendant of the UIKit remote image view we created at my current employer. I canâ€™t share the code but believe me that compared to the following SwiftUI implementation our UIKit code is more complex, uses an external framework, and has more lines of code.</p><h2>The Goal</h2><p>Letâ€™s start with a short description of the articleâ€™s goal:</p><p>Our goal is to create a view that fetches the image at a given URL, shows a loading view during fetching, caches the image, uses the existing SwiftUI image view, and shows an error view if needed.</p><p>With this end in mind, letâ€™s start coding.</p><h2>The Implementation</h2><p>The code mainly consists of three components.</p><h3>1. RemoteImageState</h3><p>The remote image view can have three different states: error, image, and loading. It should be able to render itself dependent on its current state.</p><pre><code><span class="keyword">enum</span> RemoteImageState {
    <span class="keyword">case</span> error(<span class="keyword">_</span> error: <span class="type">Error</span>)
    <span class="keyword">case</span> image(<span class="keyword">_</span> image: <span class="type">UIImage</span>)
    <span class="keyword">case</span> loading
}
</code></pre><h3>2. RemoteImageService</h3><p>We need a service that takes care of fetching and caching the image. In addition to that, it should manage the current state of the related remote image.</p><p><strong>Fetching image</strong></p><p>The HTTP request is done using the standard tools (<code>URLSession</code> and <code>URLRequest</code>) in combination with a simple data task publisher and a sink subscriber (Combine framework).</p><p><strong>Caching image</strong></p><p>Caching is done with <code>NSCache</code>. Simple, right? All remote images in one SwiftUI application should share the same cache, therefore the cache is static. The cache can easily be cleared through its <code>removeAllObjects()</code> function.</p><p><strong>State changes</strong></p><p>The service conforms to the <code>ObservableObject</code> protocol and propagates the state changes made in the <code>fetchImage</code>function through a simple <code>PassthroughSubject</code> to every subscriber.</p><pre><code><span class="keyword">final class</span> RemoteImageService: <span class="type">ObservableObject</span> {
    <span class="keyword">private var</span> cancellable: <span class="type">AnyCancellable</span>?
    
    <span class="keyword">static let</span> cache = <span class="type">NSCache</span>&lt;<span class="type">NSURL</span>, <span class="type">UIImage</span>&gt;()
    
    <span class="keyword">var</span> state: <span class="type">RemoteImageState</span> = .<span class="call">loading</span> {
        <span class="keyword">didSet</span> {
            objectWillChange.<span class="call">send</span>()
        }
    }
    
    <span class="keyword">let</span> objectWillChange = <span class="type">PassthroughSubject</span>&lt;<span class="type">Void</span>, <span class="type">Never</span>&gt;()
    
    <span class="keyword">func</span> fetchImage(atURL url: <span class="type">URL</span>) {
        cancellable?.<span class="call">cancel</span>()
        
        <span class="keyword">if let</span> image = <span class="type">RemoteImageService</span>.<span class="property">cache</span>.<span class="call">object</span>(forKey: url <span class="keyword">as</span> <span class="type">NSURL</span>) {
            state = .<span class="call">image</span>(image)
            <span class="keyword">return</span>
        }
        
        <span class="keyword">let</span> urlSession = <span class="type">URLSession</span>.<span class="property">shared</span>
        <span class="keyword">let</span> urlRequest = <span class="type">URLRequest</span>(url: url)
        
        cancellable = urlSession.<span class="call">dataTaskPublisher</span>(for: urlRequest)
            .<span class="call">map</span> { <span class="type">UIImage</span>(data: $0.<span class="property">data</span>) }
            .<span class="call">receive</span>(on: <span class="type">RunLoop</span>.<span class="property">main</span>)
            .<span class="call">sink</span>(receiveCompletion: { completion <span class="keyword">in
                switch</span> completion {
                    <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> failure):
                        <span class="keyword">self</span>.<span class="property">state</span> = .<span class="call">error</span>(failure)
                    <span class="keyword">default</span>: ()
                }
            }) { image <span class="keyword">in
                if let</span> image = image {
                    <span class="type">RemoteImageService</span>.<span class="property">cache</span>.<span class="call">setObject</span>(image, forKey: url <span class="keyword">as</span> <span class="type">NSURL</span>)
                    <span class="keyword">self</span>.<span class="property">state</span> = .<span class="call">image</span>(image)
                } <span class="keyword">else</span> {
                    <span class="keyword">self</span>.<span class="property">state</span> = .<span class="call">error</span>(<span class="type">RemoteImageServiceError</span>.<span class="property">couldNotCreateImage</span>)
                }
            }
    }
}
</code></pre><h3>3. RemoteImage</h3><p>This last component is the view itself. It uses an instance of <code>RemoteImageService</code> and renders itself dependent on the state in the service.</p><p>The initializer expects a URL and a <code>ViewBuilder</code> block for each state (error, image, and loading).</p><p><strong>Fetching image</strong></p><p>As soon as the <code>LoadingView</code> appears on the screen, the <code>fetchImage</code> function of the <code>RemoteImageService</code> instance is triggered.</p><p><strong>Customising image appearance</strong></p><p>Internally the <code>RemoteImage</code> view uses the existing Image view of SwiftUI. To be able to customise the appearance of that Image view, itâ€™s exposed through the related <code>ViewBuilder</code> block.</p><p><strong>An error occurred</strong></p><p>If an error occurs, the error view <code>ViewBuilder</code> is called. The error is passed to the <code>ViewBuilder</code> block and can be used to create an error view.</p><p><strong>AnyView</strong></p><p>In this implementation, I had to use the type erased wrapper <code>AnyView</code> to erase the different types of views returned in the switch.</p><p>Normally the Group view could solve that kind of problem. But the content block of the Group view is a <code>ViewBuilder</code>block, and you canâ€™t use the switch statement below (an enum with associated values) in a <code>ViewBuilder</code> block.</p><pre><code><span class="keyword">struct</span> RemoteImage&lt;ErrorView: <span class="type">View</span>, ImageView: <span class="type">View</span>, LoadingView: <span class="type">View</span>&gt;: <span class="type">View</span> {
    <span class="keyword">private let</span> url: <span class="type">URL</span>
    <span class="keyword">private let</span> errorView: (<span class="type">Error</span>) -&gt; <span class="type">ErrorView</span>
    <span class="keyword">private let</span> imageView: (<span class="type">Image</span>) -&gt; <span class="type">ImageView</span>
    <span class="keyword">private let</span> loadingView: () -&gt; <span class="type">LoadingView</span>
    <span class="keyword">@ObservedObject private var</span> service: <span class="type">RemoteImageService</span> = <span class="type">RemoteImageService</span>()
    
    <span class="keyword">var</span> body: <span class="type">AnyView</span> {
        <span class="keyword">switch</span> service.<span class="property">state</span> {
            <span class="keyword">case</span> .<span class="dotAccess">error</span>(<span class="keyword">let</span> error):
                <span class="keyword">return</span> <span class="type">AnyView</span>(
                    <span class="call">errorView</span>(error)
                )
            <span class="keyword">case</span> .<span class="dotAccess">image</span>(<span class="keyword">let</span> image):
                <span class="keyword">return</span> <span class="type">AnyView</span>(
                    <span class="keyword">self</span>.<span class="call">imageView</span>(<span class="type">Image</span>(uiImage: image))
                )
            <span class="keyword">case</span> .<span class="dotAccess">loading</span>:
                <span class="keyword">return</span> <span class="type">AnyView</span>(
                    <span class="call">loadingView</span>()
                    .<span class="call">onAppear</span> {
                        <span class="keyword">self</span>.<span class="property">service</span>.<span class="call">fetchImage</span>(atURL: <span class="keyword">self</span>.<span class="property">url</span>)
                    }
                )
        }
    }
    
    <span class="keyword">init</span>(url: <span class="type">URL</span>, <span class="keyword">@ViewBuilder</span> errorView: <span class="keyword">@escaping</span> (<span class="type">Error</span>) -&gt; <span class="type">ErrorView</span>, <span class="keyword">@ViewBuilder</span> imageView: <span class="keyword">@escaping</span> (<span class="type">Image</span>) -&gt; <span class="type">ImageView</span>, <span class="keyword">@ViewBuilder</span> loadingView: <span class="keyword">@escaping</span> () -&gt; <span class="type">LoadingView</span>) {
        <span class="keyword">self</span>.<span class="property">url</span> = url
        <span class="keyword">self</span>.<span class="property">errorView</span> = errorView
        <span class="keyword">self</span>.<span class="property">imageView</span> = imageView
        <span class="keyword">self</span>.<span class="property">loadingView</span> = loadingView
    }
}
</code></pre><h2>Example</h2><p>Last but not least, we take a look at a usage example.</p><p>The created Remote Image view is easy to use. Just pass a URL, your error view, your image, and your loading view to the initializer.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">private let</span> url = <span class="type">URL</span>(string: <span class="string">"https://images.unsplash.com/photo-1524419986249-348e8fa6ad4a?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1950&amp;q=80"</span>)!
    
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">RemoteImage</span>(url: url, errorView: { error <span class="keyword">in</span>
            <span class="type">Text</span>(error.<span class="property">localizedDescription</span>)
        }, imageView: { image <span class="keyword">in</span>
            image
            .<span class="call">resizable</span>()
            .<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fit</span>)
        }, loadingView: {
            <span class="type">Text</span>(<span class="string">"Loading ..."</span>)
        })
    }
}
</code></pre><p>Take a look at how I customised the appearance of the Image: I made it resizable and changed the content mode to fit.</p><img src="remote-image-view-example.gif" alt="Animated image showing the result on the iPhone XR simulator"/><p><em>Animated image showing the result on the iPhone XR simulator</em></p><h2>Conclusion</h2><p>Congratulations! You finished this lesson about creating a remote image SwiftUI view.</p><p>Thanks for reading this article. I hope you continue reading my articles. Stay tuned.</p><p>See it on GitHub at https://github.com/crelies/RemoteImage-SwiftUI</p></div><footer class="mb-3"><div class="text-center w-50 center-horizontally"><p class="text-monospace">    LegalNotice(name: "Christian Elies",
                city: "LÃ¼neburg")<br/><br/>Copyright Â© Christian Elies 2020.<br/><p class="mb-0">Generated using <a target="_blank" class="text-decoration-underline" href="https://github.com/JohnSundell/Publish">Publish</a>. 100% JavaScript-free.</p></p></div></footer></body></html>