<!DOCTYPE html><html><head><title>Personal Website</title><meta name="twitter:title" content="Personal Website"/><meta name="og:title" content="Personal Website"/><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" type="text/css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" type="text/css"/><link rel="stylesheet" href="https://crelies.github.io/christianelies.de/styles.css" type="text/css"/><meta charset="UTF-8"/></head><body><header><div class="text-center pt-4 fs-12"><a class="text-danger text-monospace"><p class="mb-0">debugPrint("Hello world!")</p></a></div><nav class="navbar navbar-expand-lg navbar-dark bg-dark justify-content-center"><div class="navbar-nav"><a class="nav-item nav-link fs-18" href="me">.me</a><a class="nav-item nav-link active fs-18" href="posts">.posts</a><a class="nav-item nav-link fs-18" href="projects">.projects</a></div></nav><ul class="list-inline text-center pb-4 mb-0"><li class="list-inline-item"><a class="text-danger" target="_blank" href="https://github.com/crelies"><i class="fab fa-github fs-14"></i></a></li><li class="list-inline-item"><a class="text-danger" target="_blank" href="https://medium.com/@crelies"><i class="fab fa-medium fs-14"></i></a></li><li class="list-inline-item"><a class="text-danger" target="_blank" href="https://stackoverflow.com/story/crelies"><i class="fab fa-stack-overflow fs-14"></i></a></li><li class="list-inline-item"><a class="text-danger" target="_blank" href="https://www.xing.com/profile/Christian_Elies2"><i class="fab fa-xing fs-14"></i></a></li><li class="list-inline-item"><a class="text-danger" target="_blank" href="https://www.linkedin.com/in/christian-elies-b1009b104"><i class="fab fa-linkedin fs-14"></i></a></li></ul></header><div class="page-wrapper text-white"><h1>VIPER üêç Architecture Evolution for¬†iOS</h1><a href="tags/viper"><span class="badge badge-pill badge-danger fs-12 text-monospace pt-2 pb-2 mr-2 mb-2">viper</span></a><a href="tags/softwarearchitecture"><span class="badge badge-pill badge-info fs-12 text-monospace pt-2 pb-2 mr-2 mb-2">software-architecture</span></a><a href="tags/ios"><span class="badge badge-pill badge-success fs-12 text-monospace pt-2 pb-2 mr-2 mb-2">ios</span></a><p class="text-danger">27. Jan 2019</p><img src="viper-architecture-header.jpg" alt="Title image"/><p><em>designed by freepik.com</em></p><p>A long time ago our iOS team decided to try the <em>VIPER</em> Architecture pattern. There are a lot of variations of that pattern around. Over time, we have had a wide variety of use cases for which the classic <em>VIPER</em> Architecture (see below) doesn‚Äôt offer standardised solutions. That‚Äôs why we modified the Architecture pattern for our needs. Now I want to share our learnings and improvements.</p><blockquote><p>For those of you who don‚Äôt know the <em>VIPER</em> Architecture pattern here is a simple example: Let‚Äôs say you want to show a list of items in your app. Normally you would only create a <em>UIViewController</em> including a <em>UIView</em> for that. Doing that the <em>VIPER</em> way means you create 5 components which all have its single responsibility.</p></blockquote><ol><li><em>View:</em> I think you all know what this component is. Most of the time it‚Äôs a <em>UIViewController</em>, sometimes it‚Äòs only a <em>UIView</em>. It shows UI elements to the user.</li><li><em>Presenter:</em> He is responsible for fetching data from the <em>Interactor</em>, for creating view models from that data and for updating the V<em>iew</em>. In addition he tells the <em>Router</em> to navigate to another <em>View or</em> to show another <em>View</em>.</li><li><em>Interactor:</em> The <em>Interactor</em> takes care of the business logic, for example fetching data from an API or local database.</li><li><em>Router:</em> As mentioned before he is responsible for navigation, maybe that means showing a modal view controller or pushing a view controller onto a navigation stack.</li><li><em>Wireframe:</em> He connects all aforementioned components and returns a ready to use <em>View</em>.</li></ol><p>In the following I will use <em>VIPER stack</em> as an alias for all the aforementioned components.</p><h2>üö∂üèæ The VIPER Architecture variation we started with</h2><p>Take a look at the <em>VIPER</em> Architecture variation we started with.</p><img src="viper-architecture-start.jpg" alt="VIPER Architecture we started with"/><p><em>VIPER Architecture we started with</em></p><p>A long time ago a new app project knocked at our door and we decided to follow this Architecture pattern for the first time. We needed some time to understand <em>VIPER</em> and this variation at all. After getting used to it we fall in love with <em>VIPER</em>.</p><p>We started with the following boilerplate code.</p><p><strong>1.</strong> The code for a <em>View</em> (<em>UIView</em> or <em>UIViewController</em>):</p><pre><code><span class="keyword">protocol</span> ViewProtocol: <span class="keyword">class</span> {}
<span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {
    <span class="keyword">private var</span> presenter: <span class="type">PresenterProtocol</span>?
}
<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">ViewProtocol</span> {}
</code></pre><p><strong>2.</strong> The code for a <em>Presenter</em>:</p><pre><code><span class="keyword">protocol</span> PresenterProtocol {}
<span class="keyword">final class</span> Presenter: <span class="type">PresenterProtocol</span> {
    <span class="keyword">private weak var</span> view: <span class="type">ViewProtocol</span>?
    <span class="keyword">private var</span> interactor: <span class="type">InteractorInputProtocol</span>?
    <span class="keyword">private var</span> router: <span class="type">RouterProtocol</span>?
}
<span class="keyword">extension</span> <span class="type">Presenter</span>: <span class="type">InteractorOutputProtocol</span> {}
</code></pre><p><strong>3.</strong> The code for an I<em>nteractor</em>:</p><pre><code><span class="keyword">protocol</span> InteractorOutputProtocol: <span class="keyword">class</span> {}
<span class="keyword">protocol</span> InteractorInputProtocol {}
<span class="keyword">final class</span> Interactor: <span class="type">InteractorInputProtocol</span> {
    <span class="keyword">private weak var</span> presenter: <span class="type">InteractorOutputProtocol</span>?
}
</code></pre><p><strong>4.</strong> The code for a <em>Router</em>:</p><pre><code><span class="keyword">protocol</span> RouterProtocol {}
<span class="keyword">final class</span> Router: <span class="type">RouterProtocol</span> {}
</code></pre><p><strong>5.</strong> The code for a W<em>ireframe</em>:</p><pre><code><span class="keyword">enum</span> WireframeError: <span class="type">Error</span> {
    <span class="keyword">case</span> couldNotInstantiateInitialViewController
}
<span class="keyword">protocol</span> WireframeProtocol {
    <span class="keyword">static func</span> makeView() <span class="keyword">throws</span> -&gt; <span class="type">ViewProtocol</span>
}
<span class="keyword">final class</span> Wireframe: <span class="type">WireframeProtocol</span> {
    <span class="keyword">static func</span> makeView() <span class="keyword">throws</span> -&gt; <span class="type">ViewProtocol</span> {
        <span class="keyword">guard let</span> view = <span class="type">UIStoryboard</span>(named: <span class="string">"View"</span>, bundle: <span class="keyword">nil</span>).<span class="call">instantiateInitialViewController</span>() <span class="keyword">as</span>? <span class="type">ViewProtocol</span> <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">WireframeError</span>.<span class="property">couldNotInstantiateInitialViewController</span>
        }
        
        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>()
        <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()
        <span class="keyword">let</span> router = <span class="type">Router</span>()
        view.<span class="property">presenter</span> = presenter
        presenter.<span class="property">view</span> = view
        presenter.<span class="property">interactor</span> = interactor
        presenter.<span class="property">router</span> = router
        interactor.<span class="property">presenter</span> = presenter
        <span class="keyword">return</span> view
    }
}
</code></pre><p>The app we created at that time had only a few views. For every view we created a <em>VIPER</em> <em>stack</em>.</p><p>Now we can move on to the 7 issues we experienced over the time following the <em>VIPER A</em>rchitecture pattern.</p><h3>1. Setting up a UICollectionView</h3><p>We wanted to integrate a <em>UICollectionView</em> in the app to show a list of items to the user. When you take a look at the above Architecture diagram it‚Äôs not obvious what‚Äôs the best way for setting up a <em>UICollectionView</em> with its delegate and data source.</p><blockquote><p>We discussed it in the team and chose a solution. The <em>Presenter</em> as the Entity responsible for creating view models and telling the <em>View</em> to update itself should take care of it.</p></blockquote><p>To do so the <em>ViewProtocol</em> should require a get only collection view property. That way the <em>Presenter</em> would be able to access the <em>UICollectionView</em>.</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">protocol</span> ViewProtocol: <span class="keyword">class</span> {
    <span class="keyword">var</span> collectionView: <span class="type">UICollectionView</span>! { <span class="keyword">get</span> }
}
<span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {
    <span class="keyword">private(set) weak var</span> collectionView: <span class="type">UICollectionView</span>!
}
<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">ViewProtocol</span> {}
</code></pre><p>Then the <em>Presenter</em> creates the delegate and data source for the <em>UICollectionView</em> and sets it up using the collection view property of the <em>View</em>. In a first version the <em>Presenter</em> was the <em>UICollectionViewDelegate</em> and <em>UICollectionViewDataSource</em>.</p><p>Apart from this the <em>Presenter</em> created view models using data fetched from the <em>Interactor</em>. Over time that introduced another problem.</p><h3>2. Presenter getting too big</h3><p>The <em>Presenter</em> file grew fast and had too many lines of code. We chose to reduce the responsibilities of the <em>Presenter</em>. We created separate reusable types for the <em>UICollectionViewDelegate</em> and <em>UICollectionViewDataSource</em>. Later on we met <a href="https://github.com/Instagram/IGListKit"><em>IGListKit</em></a> and used that instead. In addition we outsourced the view model creation to a separate type which we call <em>ViewModelCreator</em> or <em>ViewModelFactory</em>.</p><h3>3. Delegation Spaghetti code</h3><div style="width:100%;height:0;padding-bottom:56%;position:relative;"><iframe src="https://giphy.com/embed/3o7qDKdHAqamtq0uBi" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/pasta-skydiving-skydive-3o7qDKdHAqamtq0uBi">via GIPHY</a></p><p>More and more the delegation between the I<em>nteractor</em> and the <em>Presenter</em> made no sense for most of our use cases. Mostly the <em>Interactor</em> starts async tasks. The <em>Presenter</em> should react to the completion of that task right where he called the <em>Interactor</em> method.</p><blockquote><p>The <em>VIPER</em> variation we started with defines that the <em>Presenter</em> triggers an async task on the <em>Interactor</em>. At some point in the future the <em>Interactor</em> tells the <em>Presenter</em> that he finished this task. In the <em>Presenter</em> the logic which belongs together is scattered and hard to test, namely the call of the async <em>Interactor</em> method and the logic which should be executed in response (success or failure).</p></blockquote><p>Thus we removed the <em>InteractorOutputProtocol</em> and renamed the <em>InteractorInputProtocol</em> to <em>InteractorProtocol</em>. Additionally we were able to remove the <em>Presenter</em> property from the <em>Interactor</em> (see example code below). If the called <em>Interactor</em> method is asynchronous we use <a href="https://github.com/mxcl/PromiseKit"><em>PromiseKit</em></a> to return a promise. That way the code for calling the async task and for responding to the result stays together.</p><h3>4. Unnecessary optional references in Presenter</h3><p>As we created more and more <em>VIPER stacks</em> we brought the optional connections between some components into question. We unwrapped the <em>Interactor</em> and the <em>Router</em> in the <em>Presenter</em> over and over again. Then we decided that we don‚Äôt want a <em>VIPER stack</em> which has no <em>Interactor</em> or <em>Router</em>. Each <em>VIPER stack</em> should have all components to maintain uniformity when it comes to Architecture.</p><p>To make sure of that we first create the <em>Interactor</em> and the <em>Router</em> in the <em>Wireframe</em> and pass them to the initializer of the <em>Presenter</em>.</p><p>The code of the <em>Presenter</em> changes to:</p><pre><code><span class="keyword">protocol</span> PresenterProtocol {}
<span class="keyword">final class</span> Presenter: <span class="type">PresenterProtocol</span> {
    <span class="keyword">private weak var</span> view: <span class="type">ViewProtocol</span>?
    <span class="keyword">private let</span> interactor: <span class="type">InteractorProtocol</span>
    <span class="keyword">private let</span> router: <span class="type">RouterProtocol</span>
    <span class="keyword">init</span>(interactor: <span class="type">InteractorProtocol</span>, router: <span class="type">RouterProtocol</span>) {
        <span class="keyword">self</span>.<span class="property">interactor</span> = interactor
        <span class="keyword">self</span>.<span class="property">router</span> = router
    }
}
</code></pre><p>The code of the <em>Interactor</em> changes to:</p><pre><code><span class="keyword">protocol</span> InteractorProtocol {}
<span class="keyword">final class</span> Interactor: <span class="type">InteractorProtocol</span> {}
</code></pre><p>The <em>makeView</em> implementation in the <em>Wireframe</em> changes to:</p><pre><code><span class="keyword">static func</span> makeView() <span class="keyword">throws</span> -&gt; <span class="type">ViewProtocol</span> {
    ...
    <span class="keyword">let</span> interactor = <span class="type">Interactor</span>()
    <span class="keyword">let</span> router = <span class="type">Router</span>()
    <span class="keyword">let</span> presenter = <span class="type">Presenter</span>(interactor: interactor, router: router)
    presenter.<span class="property">view</span> = view
    view.<span class="property">presenter</span> = presenter
    <span class="keyword">return</span> view
}
</code></pre><h3>5. Interactor shouldn‚Äôt take care of all the business logic</h3><p>As time passed the <em>Interactor</em> did a lot of things. That‚Äôs why we decided to move some of the business logic into small, reusable and testable <em>Services</em>, which follow the <em>Single Responsibility</em> pattern. Now the <em>Interactor</em> handles less business logic, stays small and is easy to maintain.</p><h3>6. Updating the VIPER stack from the outside</h3><p>Sometimes we want to update a <em>VIPER stack</em> from the outside world. Right now it‚Äôs hard because the <em>makeView</em> method of the <em>Wireframe</em> only returns an object conforming to the <em>ViewProtocol</em>. There are ways to do that but all of them are a bit dirty.</p><p>We concluded to enter the <em>VIPER stack</em> via the already exposed <em>View</em>. First we created a <em><code>ModuleName</code>Protocol</em> which defines the interfaces of the <em>VIPER stack</em>. The <em>View</em> implements that protocol and only delegates to the <em>Presenter</em>. The <em>Presenter</em> then does something, like requesting data from the <em>Interactor,</em> creating view models and updating the data source of a UI<em>CollectionView</em>.</p><pre><code><span class="keyword">protocol</span> &lt;ModuleName&gt;<span class="type">Protocol</span>: <span class="keyword">class</span> {}
<span class="keyword">protocol</span> ViewProtocol: &lt;<span class="type">ModuleName</span>&gt;<span class="type">Protocol</span> {}
<span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {}
<span class="keyword">extension</span> <span class="type">ViewController</span>: <span class="type">ViewProtocol</span> {}
<span class="keyword">extension</span> <span class="type">ViewController</span>: &lt;<span class="type">ModuleName</span>&gt;<span class="type">Protocol</span> {}
</code></pre><p>From the outside we now have access to the properties and methods defined in the <em>Protocol</em>.</p><p>Sometimes we have nested <em>VIPER stacks</em> and want to update an underlying <em>stack</em>. We do that using the <em>Router</em> because hecreates the <em>View</em> of the underlying <em>VIPER stack</em> with the help of a <em>Wireframe</em>. The <em>Router</em> only needs to store a reference to that <em>View</em> and use it later on to update the underlying <em>VIPER stack</em>.</p><h3>7. Communicating with the outside from inside a VIPER stack</h3><p>Occasionally we want to notify the outside world that something inside a specific <em>VIPER stack</em> happened. We had to decide which component should do that. Over time we more and more saw the <em>Presenter</em> as some kind of <em>Man in the Middle</em>. That‚Äôs why he gets an object conforming to <em><code>ModuleName</code>DelegateProtocol</em> and calls the delegate methods if needed.</p><pre><code><span class="keyword">protocol</span> &lt;ModuleName&gt;<span class="type">DelegateProtocol</span>: <span class="keyword">class</span> {}
<span class="keyword">protocol</span> PresenterProtocol {}
<span class="keyword">final class</span> Presenter: <span class="type">PresenterProtocol</span> {
    <span class="keyword">private weak var</span> view: <span class="type">ViewProtocol</span>?
    <span class="keyword">private let</span> interactor: <span class="type">InteractorProtocol</span>
    <span class="keyword">private let</span> router: <span class="type">RouterProtocol</span>
    <span class="keyword">private weak var</span> delegate: &lt;<span class="type">ModuleName</span>&gt;<span class="type">DelegateProtocol</span>?
    <span class="keyword">init</span>(interactor: <span class="type">InteractorProtocol</span>, router: <span class="type">RouterProtocol</span>, delegate: &lt;<span class="type">ModuleName</span>&gt;<span class="type">DelegateProtocol</span>?) {
        <span class="keyword">self</span>.<span class="property">interactor</span> = interactor
        <span class="keyword">self</span>.<span class="property">router</span> = router
        <span class="keyword">self</span>.<span class="property">delegate</span> = delegate
    }
}
</code></pre><p>A simple real world example shows the need for communicating with the outside. Think about 2 views, one view showing a list of items and another view showing the details of one item.</p><blockquote><p>We would create a <em>VIPER stack</em> for each view. If the user selects an item from the list we would use the <em>Router</em> to present the <em>View</em> for the item details. That‚Äôs easy. But if the user updates the item details we want to reflect these changes in the list after returning to it.</p></blockquote><p>To do so we create a delegate protocol for the item details <em>VIPER stack</em>. The <em>Presenter</em> of the item list <em>VIPER stack</em>conforms to that protocol. We pass him to the <em>makeView</em> method of the <em>Wireframe</em> for the item details <em>VIPER stack</em>. The <em>Wireframe</em> then passes it to the <em>Presenter</em> which stores the reference and calls an appropriate method on the delegate after the details of an item have been updated.</p><pre><code><span class="keyword">protocol</span> ItemDetailsDelegateProtocol: <span class="keyword">class</span> {
    <span class="call">didUpdateDetails</span>(ofItem item: <span class="type">Item</span>)
}
...
<span class="keyword">extension</span> <span class="type">ItemListPresenter</span>: <span class="type">ItemDetailsDelegateProtocol</span> {
    <span class="call">didUpdateDetails</span>(ofItem item: <span class="type">Item</span>) {
        <span class="call">updateList</span>()
    }
}
...
<span class="keyword">final class</span> ItemDetailsWireframe: <span class="type">ItemDetailsWireframeProtocol</span> {
    <span class="keyword">static func</span> makeView(usingDelegate delegate: <span class="type">ItemDetailsDelegateProtocol</span>?) <span class="keyword">throws</span> -&gt; <span class="type">ViewProtocol</span> {
        ...
        <span class="keyword">let</span> presenter = <span class="type">Presenter</span>(interactor: interactor, router: router, delegate: delegate)
        ...
        <span class="keyword">return</span> view
    }
}
</code></pre><p>Finally we take a look at the Architecture Evolution.</p><h2>üöÄ VIPER Architecture Evolution</h2><img src="viper-architecture-end.jpg" alt="VIPER Architecture Evolution"/><p><em>VIPER Architecture Evolution</em></p><p>That‚Äôs the <em>VIPER</em> Architecture variation we developed over time.</p><blockquote><p>We are very happy with it. The code we write following the pattern is easy to <strong>maintain</strong> and to <strong>test</strong>. It forces us to write <strong>independent modules</strong> and makes it <strong>easy to outsource</strong> them into separate projects. As always: <strong>Divide and conquer</strong>. To make the daily business easier we created a <a href="https://github.com/crelies/Viper-Xcode-Template">Xcode Template</a> for our <em>VIPER</em>Architecture variation.</p></blockquote><h3>Oh wait ‚úã ‚Ä¶ what about Dependency Injection?</h3><p>We want to inject dependencies into the <em>VIPER</em> components. At the beginning we passed the dependencies of each component into their initializers. That led to huge initializers and was hard to maintain.</p><p>One of my colleagues had a great idea - to use only Swift <em>Protocols</em> and <em>Structs.</em> An easy to use and native dependency injection system was born. I‚Äôll talk about that in a different story. Stay tuned :-)</p><p>Finally I would love to hear what you think about <em>VIPER</em> and especially about our Evolution. I know that <em>VIPER</em> is very controversial ;) And yes, we know about <em>VIP</em> but right now I‚Äôm not convinced.</p><h3>Links</h3><ul><li><a href="https://github.com/Instagram/IGListKit">IGListKit</a></li><li><a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></li><li><a href="https://github.com/crelies/Viper-Xcode-Template">Viper-Xcode-Template</a></li></ul><p><a href="https://github.com/crelies/"><strong>crelies - Overview</strong></a></p></div><footer class="mb-3"><div class="text-center fs-12 w-50 center-horizontally"><p class="text-danger text-monospace">    LegalNotice(name: "Christian Elies",
                city: "L√ºneburg")<br/><br/>Copyright ¬© Christian Elies 2020.<br/><p class="text-danger mb-0">Generated using <a target="_blank" class="text-danger text-decoration-underline" href="https://github.com/JohnSundell/Publish">Publish</a>. 100% JavaScript-free.</p></p></div></footer></body></html>